<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode最后一个单词的长度]]></title>
    <url>%2F2019%2F10%2F14%2Fleetcode%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[##Leetcode ###题目 123456789101112131415给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。说明：一个单词是指由字母组成，但不包含任何空格的字符串。示例:输入: "Hello World"输出: 5来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/length-of-last-word著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ###题解 1234567891011121314151617181920class Solution &#123;public: int lengthOfLastWord(string s) &#123; if(s.size()==0)//如果字符串长度为0 则说明单词不存在 return 0; int j=0; //记录单词长度 for(int i = s.size()-1;i&gt;=0;i--) &#123; // if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'||s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z') if(s[i]!=' ')//如果字符串中元素等于' '时则不执行 j++; else if(j&gt;0) //因为可能存在在字符串的最后有一连串" "所以要确保单词存在时且长度大于0时才是正确的 return j;//返回最后一个单词的长度 &#125; return j; &#125;&#125;;]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode实现strStr()]]></title>
    <url>%2F2019%2F10%2F14%2Fleetcode%E5%AE%9E%E7%8E%B0strStr()%2F</url>
    <content type="text"><![CDATA[##Leetcode ###题目 123456789101112131415161718192021实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。示例 1:输入: haystack = "hello", needle = "ll"输出: 2示例 2:输入: haystack = "aaaaa", needle = "bba"输出: -1说明:当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ###题解 12345678910111213141516171819202122232425262728class Solution &#123;public: int strStr(string haystack, string needle) &#123; if(needle.empty()) return 0; int i=0,j=0; while(haystack[i]!='\0'&amp;&amp;needle[j]!='\0')//同时遍历比较，且这样的循环条件保证了needle中下标不会越界 &#123; if(haystack[i]==needle[j]) &#123; i++; j++; &#125; else &#123; i=i-j+1; j=0; //保证了每次needle都是从第一个元素开始比较 &#125; &#125; if(needle[j]=='\0') return i-j; return -1; &#125;&#125;;]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode有效的括号]]></title>
    <url>%2F2019%2F10%2F14%2Fleetcode%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; sta; for(const auto&amp; v : s) //范围for &#123; if(sta.empty()) //如果栈为空 在栈底添加元素v sta.push(v); else if(compare(sta.top(),v))//如果栈不为空，将元素v与栈顶元素比较 sta.pop(); //如果栈顶元素与元素v是相匹配的闭合括号，就删除栈顶元素 else sta.push(v);//如果不匹配将元素v入栈 &#125; return sta.size()==0 ? true : false; &#125;private: bool compare(const char&amp; c1,const char&amp; c2) &#123; return (c1 == '(' &amp;&amp; c2 == ')') || (c1 == '[' &amp;&amp; c2 == ']') || (c1 == '&#123;' &amp;&amp; c2 == '&#125;'); &#125;&#125;;]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode实现数组加一的操作]]></title>
    <url>%2F2019%2F10%2F14%2Fleetcode%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8A%A0%E4%B8%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for(int i = digits.size()-1;i&gt;=0;i--) &#123; digits[i]++; //加一 digits[i]=digits[i]%10;//取余数 if(digits[i]!=0)//其实也就是当对应下标元素值不为9时 返回数组 return digits; &#125;//如果数组中全部为9 循环结束时 数组中元素全为0 digits.push_back(0);//在容器尾部添加0 digits[0] = 1; return digits; &#125;&#125;;/* 存在9的几种情况 : 1.当末位只有一个9 2.不连续的9 3.后边有连续的9 4.全是9 */]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode实现x的平方根函数]]></title>
    <url>%2F2019%2F10%2F14%2Fleetcode%E5%AE%9E%E7%8E%B0x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031 class Solution &#123; public: int mySqrt(int x) &#123; if(x==0) return 0; long left = 1; long right = x/2+1;// # 为了照顾到 1 把右边界设置为 x // 2 + 1 while(left&lt;right) &#123; // 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环 // long mid = left + (right - left + 1) / 2; long mid = (left+right+1) &gt;&gt; 1; //mid一定要在循环体内 不然无法重置mid的值 if(mid*mid&gt;x) &#123; right = mid-1; &#125; else &#123; left = mid; &#125; &#125; // 因为一定存在，因此无需后处理 return (int)left; &#125;&#125;;]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode回文数]]></title>
    <url>%2F2019%2F10%2F06%2Fleetcode%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Leetcode回文数1234567891011121314151617class Solution &#123;public: bool isPalindrome(int x) &#123; int k=0;//存储后半部分数字的反转结果 if(x&lt;0||(x%10==0&amp;&amp;x!=0))//排除负数和最后一位数字为0的数字 return false; while(x&gt;k) &#123; k = k*10+x%10; x/=10; &#125; return k==x || k/10==x;//数字个数为偶数和奇数分两种情况 &#125; &#125;；]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于网易云歌曲外链获取方法]]></title>
    <url>%2F2019%2F10%2F04%2F%E5%85%B3%E4%BA%8E%E7%BD%91%E6%98%93%E4%BA%91%E6%AD%8C%E6%9B%B2%E5%A4%96%E9%93%BE%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[首先 找到你要下载的歌曲 用网页版打开 复制链接中的歌曲ID 如：Mike Zhou - The Dawn (亡灵序曲完美钢琴版) [Cover Dreamtale]http://music.163.com/#/song?id=476592630ID就是476592630然后将ID替换到链接 http://music.163.com/song/media/outer/url?id= .mp3 中如：http://music.163.com/song/media/outer/url?id=476592630.mp3复制这个链接 就可以直接通过网页打开纯mp3地址了 添加到下载工具中也可下载 还能添加到QQ空间背景音乐中原作者：Mike-Zhou链接：http://music.163.com/#/topic?id=18506054 http://wap.a9vg.com/thread-5363888-1-1.html]]></content>
      <tags>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F01%2FHello-World-0%2F</url>
    <content type="text"><![CDATA[I wanna be a rabbit]]></content>
      <tags>
        <tag>Just a test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的朋友们]]></title>
    <url>%2Ffriends%2Findex.html</url>
    <content type="text"><![CDATA[名称：Ncyue主页：https://www.ncyue.top/头像：http://5b0988e595225.cdn.sohucs.com/images/20190502/caa1c9e1724c43368abdfac5cb3b155b.jpeg标签：C/C++,Java,考研简介：只要你不害怕，没有人，能挡住你的去向。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[YSL's Blog | ABOUT document.onkeydown = function () { if (window.event && window.event.keyCode == 123) { event.keyCode = 0; event.returnValue = false; return false; } }; 江湖名称：Ncyue 常驻之地：中国| 河南 | 郑州 初度之辰：2000 兴趣爱好：LOL | 编程 | 听歌 技能 | Skill HTML/CSS/JS 1% C/C++ 20% JAVA 1% PYTHON 1% HEXO/GIT 30% PS/PR/AE 1% 简介 | Introduction 学历：在校本科计算机科学与技术大二学生； 现况：自学C/C++中； 目标：先考上985/211名校研究生； 博客：一个记录小白的成长过程； 其他：虽然现在很菜很菜，但是坚信一定会变的好起来； 联系我 | Contact me 此界面由技术大佬 : TRHX提供更多请关注 THRX'S BLOG. All rights reserved. if ('addEventListener' in window) { window.addEventListener('load', function () { document.body.className = document.body.className.replace(/\bis-loading\b/, ''); }); document.body.className += (navigator.userAgent.match(/(MSIE|rv:11\.0)/) ? ' is-ie' : ''); } uniform mat4 uProjection; uniform mat4 uModelview; uniform vec3 uResolution; uniform vec3 uOffset; uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start attribute vec3 aPosition; attribute vec3 aEuler; attribute vec2 aMisc; //x:size, y:fade varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; void main(void) { // Projection is based on vertical angle vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0); gl_Position = uProjection * pos; gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5; pposition = pos.xyz; psize = aMisc.x; pdist = length(pos.xyz); palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z); vec3 elrsn = sin(aEuler); vec3 elrcs = cos(aEuler); mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, elrcs.x, elrsn.x, 0.0, -elrsn.x, elrcs.x ); mat3 roty = mat3( elrcs.y, 0.0, -elrsn.y, 0.0, 1.0, 0.0, elrsn.y, 0.0, elrcs.y ); mat3 rotz = mat3( elrcs.z, elrsn.z, 0.0, -elrsn.z, elrcs.z, 0.0, 0.0, 0.0, 1.0 ); mat3 rotmat = rotx * roty * rotz; normal = rotmat[2]; mat3 trrotm = mat3( rotmat[0][0], rotmat[1][0], rotmat[2][0], rotmat[0][1], rotmat[1][1], rotmat[2][1], rotmat[0][2], rotmat[1][2], rotmat[2][2] ); normX = trrotm[0]; normY = trrotm[1]; normZ = trrotm[2]; const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237); float tmpdfs = dot(lit, normal); if(tmpdfs < 0.0) { normal = -normal; tmpdfs = dot(lit, normal); } diffuse = 0.4 + tmpdfs; vec3 eyev = normalize(-pos.xyz); if(dot(eyev, normal) > 0.0) { vec3 hv = normalize(eyev + lit); specular = pow(max(dot(hv, normal), 0.0), 20.0); } else { specular = 0.0; } rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0); rstop = pow(rstop, 0.5); //-0.69315 = ln(0.5) distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y)); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start const vec3 fadeCol = vec3(0.08, 0.03, 0.06); varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; float ellipse(vec2 p, vec2 o, vec2 r) { vec2 lp = (p - o) / r; return length(lp) - 1.0; } void main(void) { vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0; vec3 d = vec3(0.0, 0.0, -1.0); float nd = normZ.z; //dot(-normZ, d); if(abs(nd) < 0.0001) discard; float np = dot(normZ, p); vec3 tp = p + d * np / nd; vec2 coord = vec2(dot(normX, tp), dot(normY, tp)); //angle = 15 degree const float flwrsn = 0.258819045102521; const float flwrcs = 0.965925826289068; mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs); vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm; float r; if(flwrp.x < 0.0) { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5); } else { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5); } if(r > rstop) discard; vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r); float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35)); col *= vec3(1.0, grady, grady); col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3)); col = col * diffuse + specular; col = mix(fadeCol, col, distancefade); float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0; alpha = smoothstep(0.0, 1.0, alpha) * palpha; gl_FragColor = vec4(col * 0.5, alpha); } uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec2 uTimes; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec3 col; float c; vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0); c = exp(-pow(length(tmpv) * 1.8, 2.0)); col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c); gl_FragColor = vec4(col * 0.5, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; uniform vec4 uBlurDir; //dir(x, y), stride(z, w) varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta); col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta); gl_FragColor = col / 5.0; } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_FragColor = texture2D(uSrc, texCoord); } uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform sampler2D uBloom; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 srccol = texture2D(uSrc, texCoord) * 2.0; vec4 bloomcol = texture2D(uBloom, texCoord); vec4 col; col = srccol + bloomcol * (vec4(1.0) + srccol); col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5); col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2) gl_FragColor = vec4(col.rgb, 1.0); gl_FragColor.a = 1.0; } L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});]]></content>
  </entry>
  <entry>
    <title><![CDATA[所有分类]]></title>
    <url>%2Fblog%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2019]]></title>
    <url>%2Fblog%2Farchives%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[所有标签]]></title>
    <url>%2Fblog%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
